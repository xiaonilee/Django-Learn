## 08.25.2020

## migrations
- 分两部实现
    - 生成迁移文件
    - 执行迁移文件
- 迁移文件的生成过程(迁移原理)
    - 根据models文件生成对应的迁移文件
    - 根据models和已有的迁移文件差别来生成新的迁移文件
- 执行迁移文件（迁移原理）
    - 先去迁移记录查找，有哪些文件没有迁移过
        - 比对规则：根据app_label+迁移文件名字
    - 执行没有迁移的文件
    - 执行完毕，记录执行过的迁移文件
- 重新迁移
    - 删除迁移文件
    - 删除迁移文件产生的表的变更
    - 删除迁移记录
    
    
## 08.25.2020


## models 关系
- 1：1
    - 应用场景
        - 用于复杂表的拆分
        - 扩展新功能
    - Django中OneToOneFiled
        - 使用的时候，关系声明还是有细微的差别的
    - 实现
        - 使用外键实现的
        - 对外键添加了唯一的约束
    - 数据删除
        - 级连表
            - 主表
            - 从表
            - 谁声明关系谁就是从表
            - 在开发中如何确认主从
                - 当系统遭遇不可避免的毁灭时，只能保留一张表，该表就是主表
        - 默认特性（CASECADE）
            - 从表数据删除，主表不受影响
            - 主表数据删除，从表数据直接删除
        - PROTECT受保护
            - 开发中为了防止误操作，我们通常会设置为此模式
            - 主表如果存在级连数据，删除动作受到保护，无法成功删除
            - 主表如果不存在级连数据，可以删除成功
        - SET
            - SET_NULL
                - 允许为NULL
            - SET_DEFAULT
                - 存在默认值
            - SET()
                - 指定值
        - 级连数据获取
            - 主获取从，隐性属性，默认就是级连模型的名字
            - 从获取主，显性属性，就是属性的名字
- 1：M
    - ForeignKey
    - 主获取从， 隐性属性，级连模型_set
        - eg, student_set, Manager的子类
            - all
            - filter
            - exclude
            - Manager上能用的函数都能使用
     - 从获取主
        - 显性属性，就是属性的名字
- M：M
    - 实际上最复杂
    - 开发中很少直接使用多对多属性，而是自己维护多对多的关系
    - 产生表的时候会产生单独的关系表
        - 关系表中存储关联表的主键，通过多个外键实现的
        - 多个外键值不能同时相等
    - 级连数据获取
        - 从获取主
            - 使用属性，属性是Manager的子类
        - 主获取从
            - 隐性属性
                - 也是Manager的子类，操作和从操作完全一样
    - 级连数据
        - add
        - remove
        - clear
        - set
    - ManyRelatedManager
        - 函数中定义的类
        - 父类是一个参数
        - 动态创建
        
        
## 模型继承
- Django中模型支持继承
- 默认继承是会将通用字段放到父表中，特定字段放到自己的表中，中间使用外键连接
    - 关系型数据库，关系越复杂，效率越低，查询越慢
    - 父表中也会存储过多的数据，导致效率低下
- 使用元信息进行解决上述问题
    - 使模型抽象化
    - 抽象的模型就不会在数据库中产生映射
    - 子模型映射出来的表直接包含在父模型的字段
    
    
## 在企业中开发
- model -> sql
    - eg, project DjangoModel,etc
- sql -> model
    - django提供了很好的支持
    - python manage.py inspectdb
        - 可以直接根据数据库表来生成模型
        - 拥有元信息，元信息中包含一个属性 managed = False
- 如果自己的模型不想被迁移系统管理，也可以使用managed = False进行声明
